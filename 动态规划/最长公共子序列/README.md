# 最长公共子序列(LCS) 经典动态规划问题

一个给定序列的子序列是在该序列中删去若干元素后得到序列，给定两个序列 `X` 和 `Y` ，当另一序列 `Z` 既是 `X` 的子序列又是 `Y` 的子序列时，称 `Z` 是序列 `X` 和 `Y` 的公共子序列。

>例如 `X = {A,B,C,B,D,A,B}`, `Y = {B,D,C,A,B,A}`，那么序列 `{B,C,A}` 是 X 和 Y 的一个公共子序列，但它不是最长公共子序列。<br>
>序列 `{B,C,B,A}` 也是 `X` 和 `Y` 的一个公共子序列，而且它就是 `X` 和 `Y` 的最长公共子序列，由于其长度为4，所以我们说序列 `X` 和 `Y` 没有长度超过4的子序列。

## 题目描述

给定两个序列 `X = {x1,x2,x3,x4,...}` 和 `Y = {y1,y2,y3,y4,...}`，找出其最长公共子序列

### 动态规划算法可以有效解决此类问题

## 分析

### 1. 最长公共子序列的结构

设序列 `X = {x1,x2,...,xm}`, 序列 `Y = {y1,y2,...,yn}` 的最长公共子序列为 `Z = {z1,z2,z3,...,zk}`,则<br>

1. 若 `xm=yn`, 则 `zk=xm=yn`, 且 `Z(k-1)` 是 `X(m-1)` 和 `Y(n-1)` 的最长公共子序列
2. 若 `xm≠yn`, 且 `zk≠xm`, 则 `Z` 是 `X(m-1)` 和 `Y` 的最长公共子序列
3. 若 `xm≠yn`, 且 `zk≠yn`, 则 `Z` 是 `Y(n-1)` 和 `X` 的最长公共子序列

其中，`X(m-1) = {x1,x2,...,x(m-1)}`; `Y(n-1) = {y1,y2,...,y(m-1)}`; `Z(k-1) = {z1,z2,...,z(k-1)}`  

### 2. 子问题的递归结构

由上文得知要求 `X` 和 `Y` 的最长公共子序列，可按一下方式递归计算：
- 当 `xm=yn` 时，找出 `X(m-1)` 和 `Y(n-1)` 的最长公共子序列。
- 当 `xm≠yn` 时，必须解两个子问题，即找出 `X(m-1)` 和 `Y` 的一个最长公共子序列及 `X` 和 `Y(n-1)` 的一个最长公共子序列，这两个公共子序列中较长者就是 `X` 和 `Y` 的最长公共子序列。

#### 由此递归结构容易看到最长公共子序列问题具有子问题重叠性质

例如，在计算 `X` 和 `Y` 的最长公共子序列时，可能要计算 `X` 和 `Y(n-1)` 及 `X(m-1)` 和 `Y` 的最长公共子序列，而这两个问题都包含一个子问题，即计算 `X(m-1)` 和 `Y(n-1)` 最长公共子序列

#### 建立递归关系式

首先建立子问题最优值的递归关系：<br>
用 `c[i][j]` 记录序列 `X(i)` 和 `Y(j)` 的最长公共子序列的**长度**，其中 `X(i) = {x1,x2,...,x(i)}`; `Y(j) = {y1,y2,...,y(j)}`。当 `i=0` 或 `j=0` 时，空序列是 `X(i)` 和 `Y(j)` 的最长公共子序列，故此时 `c[i][j]=0`。其他情况下，由最优子结构性质可建立递归关系如下：<br>

```py
if i == 0 and j == 0:
    c[i][j] = 0
elif i > 0 and j > 0 and x[i] == y[j]:
    c[i][j] = c[i - 1][j - 1] + 1
elif i > 0 and j > 0 and x[i] != y[j]:
    c[i][j] = max(c[i][j - 1], c[i - 1][j])
```

### 3. 计算最优值

直接利用递归关系式容易写出计算 `c[i][j]` 的递归算法，但其计算时间是随着输入长度指数增长的。由于在所考虑的子问题空间中总共有 `θ(mn)` 个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。<br>

计算最长公共子序列长度的动态规划算法以序列 `X = {x1,x2,...,xm}` 和 `Y = {y1,y2,...,yn}` 作为输入。输出两个数组 c 和 b ，其中 `c[i][j]` 存储 `Xi` 和 `Yj` 的最长公共子序列的长度， `b[i][j]` 记录 `c[i][j]` 的值是由哪一个子问题的解得到的，在构造最长公共子序列时要用到，问题的最优值，即 X 和 Y 的最长公共子序列的长度记录于 `c[m][n]` 中。

```py
class value:
    array_b = None
    array_c = None
    def __init__(self,m,n):
        self.array_b = [([0] * m) for _ in range(n)]
        self.array_c = [([0] * m) for _ in range(n)]

def ics_len(list_x,list_y, res:value) -> value:
    m = len(list_x)
    n = len(list_y)
    #res.array_c = [[0 for i in range(n)] for j in range(m)]
    for i in range(1,m):
        for j in range(1,n):
            if list_x[i] == list_y[j]:
                res.array_c[i][j] = res.array_c[i - 1][j - 1] + 1
                res.array_b[i][j] = 1
            elif res.array_c[i - 1][j] >= c[i][j - 1]:
                res.array_c[i][j] = res.array_c[i - 1][j]
                res.array_b[i][j] = 2
            else:
                res.array_c[i][j] = res.array_c[i][j - 1]
                res.array_b[i][j] = 3
    return res
```

由于每个数组单元计算耗时 `O(1)`，因此算法耗时 `O(mn)`,注意此算法数组的首位没有使用

### 4. 构造最长公共子序列

由算法计算得到的数组 b 可用于快速构造序列 `X = {x1,x2,...,xm}` 和 `Y = {y1,y2,...,yn}` 的最长公共子序列。首先从 `b[m][n]` 开始，根据其值在数组 b 中搜索。

- 当 `b[i][j] = 1` 时，表示 `Xi` 和 `Yj` 的最长公共子序列的是由`X(i - 1)` 和 `Y(j - 1)` 的最长公共子序列在尾部加上 `xi` 所得到的子序列；
- 当 `b[i][j] = 2` 时，表示 `Xi` 和 `Yj` 的最长公共子序列与`X(i - 1)` 和 `Y` 的最长公共子序列相同；
- 当 `b[i][j] = 2` 时，表示 `Xi` 和 `Yj` 的最长公共子序列与`Xi` 和 `Y(j - 1)` 的最长公共子序列相同；

下面给出求出最长公共子序列的算法：
```py

def lcs_r(i, j, list_x, res: value):
    if i == 0 or j == 0:
        return
    if res.array_b[i][j] == 1:
        lcs_r(i - 1, j - 1, list_x, res)
        print(list_x[i])
    elif res.array_b[i][j] == 2:
        lcs_r(i - 1, j, list_x, res)
    else:
        lcs_r(i, j - 1, list_x, res)
```

上述算法每一次递归使 `i` 或 `j` 减1，因此算法的计算时间为 `O(m + n)`

## 具体实现算法请看 `LCS.py`
